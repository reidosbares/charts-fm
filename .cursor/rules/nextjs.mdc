---
description: Next.js, React, and TypeScript development guidelines
globs: app/**/*.{ts,tsx},components/**/*.{ts,tsx},lib/**/*.ts,contexts/**/*.{ts,tsx}
alwaysApply: false
---

You are an expert in TypeScript, Next.js, React, and scalable web application development.

# Key Principles

- Write clear, technical responses with precise Next.js and React examples.
- Use Next.js built-in features and App Router capabilities wherever possible to leverage its full potential.
- Prioritize readability and maintainability; follow TypeScript and React best practices.
- Use descriptive variable and function names; adhere to naming conventions (e.g., camelCase for variables/functions, PascalCase for components).
- Structure your project in a modular way using Next.js App Router conventions to promote reusability and separation of concerns.

# Next.js/React/TypeScript

- Use Next.js App Router for routing and file-based routing conventions.
- Leverage Server Components by default; use Client Components only when necessary (interactivity, hooks, browser APIs).
- Use Next.js API Routes (route.ts files) for backend logic and data mutations.
- Utilize React Server Components for data fetching and rendering to optimize performance.
- Follow the component-based architecture pattern for clear separation of concerns.
- Use Next.js middleware judiciously to handle cross-cutting concerns like authentication, logging, and request modification.
- Prefer TypeScript strict mode and type safety throughout the codebase.

# Error Handling and Validation

- Implement error handling at the API route level and use Next.js error boundaries for UI errors.
- Use TypeScript types and Zod (or similar) for runtime validation of API request/response data.
- Prefer try-catch blocks for handling exceptions in API routes and async operations.
- Customize error pages (error.tsx, not-found.tsx) to improve user experience and provide helpful information.
- Use React Error Boundaries for component-level error handling.
- Return consistent error responses from API routes (e.g., `{ error: string }` with appropriate HTTP status codes).

# Dependencies

- Next.js 14+ (App Router)
- React 18+
- TypeScript
- Prisma (for database ORM)
- NextAuth (for authentication)
- Tailwind CSS (for styling)

# Next.js-Specific Guidelines

- Use Server Components by default; mark components with 'use client' only when needed.
- Keep business logic in lib/ utilities and service files; keep API routes focused on request handling.
- Use Next.js file-based routing (app directory) to define clear and RESTful URL patterns.
- Apply Next.js security best practices (e.g., CSRF protection via Next.js, SQL injection protection via Prisma, XSS prevention via React).
- Use TypeScript for type safety and leverage Prisma's generated types.
- Leverage Next.js caching strategies (fetch cache, route segment config) to optimize performance.
- Use Next.js middleware for common tasks such as authentication, logging, and request modification.
- Prefer async Server Components and API routes for data fetching.

# Performance Optimization

- Optimize query performance using Prisma's include, select, and relation loading features.
- Use Next.js caching (fetch cache, route segment config) to reduce database load and API calls.
- Implement database indexing via Prisma schema for better query performance.
- Use Server Components for data fetching to reduce client-side JavaScript and improve initial load.
- Leverage Next.js Image component for optimized image handling.
- Use dynamic imports and code splitting for large components or libraries.
- Implement ISR (Incremental Static Regeneration) or SSG (Static Site Generation) where appropriate.

# Key Conventions

1. Follow Next.js "Convention Over Configuration" principle for routing and file structure.
2. Prioritize security and performance optimization in every stage of development.
3. Maintain a clear and logical project structure following Next.js App Router conventions.
4. Use TypeScript strict mode and avoid `any` types; prefer proper type definitions.
5. Keep API routes in app/api/ directory following RESTful conventions.

# API Routes and Client Components

When working on a Next.js API route (route.ts) or a Client Component handling user interactions, always ensure:
- Proper authentication checks using `getSession()` from `@/lib/auth` before accessing protected resources.
- Input validation and error handling are robust and user-friendly.
- API responses are consistent and follow a clear structure (e.g., always return JSON with `success`, `error`, and `data` keys where appropriate).
- Proper HTTP status codes are used (200, 201, 400, 401, 403, 404, 500).
- Database operations use Prisma with proper error handling and transaction support when needed.
- If the API route or component introduces new UI elements or user interactions, consider adding data attributes for testing purposes.
- For data-changing operations, ensure proper authorization checks (e.g., verify user owns the resource or has permission).
- Use NextResponse.json() for consistent JSON responses in API routes.
- Handle edge cases (e.g., missing data, invalid IDs, unauthorized access) gracefully.

# Database and Prisma

- Use Prisma Client for all database operations; avoid raw SQL queries unless necessary for performance.
- Leverage Prisma's type safety and generated types throughout the application.
- Use Prisma transactions for operations that require atomicity.
- Implement proper error handling for database operations (e.g., unique constraint violations, foreign key errors).
- Use Prisma's include and select to optimize queries and avoid N+1 problems.
- Follow the Prisma schema conventions and keep migrations version-controlled.

Refer to Next.js documentation for best practices in routing, data fetching, and security considerations.

# Next.js Build and Type Safety Requirements

- Always run `npm run type-check` before committing to catch all TypeScript errors at once
- Fix all TypeScript and ESLint errors before deployment

# Suspense Boundaries for Dynamic Hooks

- ALWAYS wrap components using `useSearchParams()` in a Suspense boundary
- Pattern to follow:
  ```tsx
  'use client'
  import { Suspense } from 'react'
  import { useSearchParams } from 'next/navigation'
  
  function MyPageContent() {
    const searchParams = useSearchParams()
    // ... component logic
  }
  
  export default function MyPage() {
    return (
      <Suspense fallback={<LoadingComponent />}>
        <MyPageContent />
      </Suspense>
    )
  }
  ```
- Required for: any page that uses `useSearchParams()`, `usePathname()`, or other dynamic hooks
- This prevents Next.js build errors: "useSearchParams() should be wrapped in a suspense boundary"

# Dynamic Route Configuration

- API routes that use `request.url` MUST be marked as dynamic
- Add `export const dynamic = 'force-dynamic'` at the top of route.ts files that:
  - Access `request.url` or `new URL(request.url)`
  - Use `searchParams` from request
  - Perform dynamic operations that can't be statically generated
- Example:
  ```tsx
  import { NextResponse } from 'next/server'
  
  export const dynamic = 'force-dynamic'
  
  export async function GET(request: Request) {
    const { searchParams } = new URL(request.url)
    // ...
  }
  ```

# NextAuth Route Handler Requirements

- Route handlers in `app/api/auth/[...nextauth]/route.ts` MUST only export HTTP method handlers (GET, POST)
- DO NOT export `authOptions` or other configuration from route files
- Pattern to follow:
  ```tsx
  // lib/auth-config.ts
  export const authOptions: NextAuthOptions = { ... }
  
  // app/api/auth/[...nextauth]/route.ts
  import NextAuth from "next-auth"
  import { authOptions } from "@/lib/auth-config"
  
  const handler = NextAuth(authOptions)
  export { handler as GET, handler as POST }
  ```

# TypeScript Type Safety

- Use `as unknown as TargetType` for JSON type conversions from Prisma (e.g., `Json` fields)
- Example: `(data.topArtists as unknown as TopItem[]) || []`
- Filter out null values before using them as Map keys or required properties
- Always check for null/undefined before accessing optional properties
- Use type assertions (`as any`) sparingly and only when necessary for complex type mismatches

# Excel/Number Type Conversions

- When pushing numbers to Excel rows, convert to strings: `value.toString()`
- Handle nullable numbers: `value?.toString() || ''`
- Example: `row.push(entry.position.toString())`

# JSON Field Type Handling

- Prisma `Json` fields return `JsonValue` type which needs explicit casting
- Always use double casting: `as unknown as TargetType` for JSON conversions
- Filter and validate JSON data before type assertions
- Example patterns:
  ```tsx
  const items = (jsonField as unknown as ItemType[]) || []
  const member = (jsonField as unknown as MemberType)
  ```

# Null Safety for Database Relations

- Always check for null before accessing optional relations (e.g., `group.creator`)
- Use optional chaining: `group.creator?.name || 'Unknown'`
- Filter out null relations when passing to components expecting non-null types
- Use type assertions when filtering: `filtered as any` if TypeScript can't infer the filtered type

# Function Argument Count

- Verify function signatures match call sites
- Remove unnecessary `undefined` arguments
- Ensure optional parameters are in the correct order
- Check Prisma/utility function signatures when refactoring

# ESLint Configuration

- Disable blocking rules in `.eslintrc.json` if needed for deployment:
  ```json
  {
    "extends": "next/core-web-vitals",
    "rules": {
      "react/no-unescaped-entities": "off",
      "@next/next/no-img-element": "warn"
    }
  }
  ```
- Prefer fixing issues over disabling rules when possible
- Use `warn` instead of `off` for non-critical rules
